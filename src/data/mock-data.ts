

export const mockQuestions = [
  {
    "question": "In React, explain the difference between **state** and **props**, and describe a common scenario where you would use the `useEffect` hook to manage side effects.",
    "answer": "The primary difference is that **props** (short for properties) are used to pass data from a parent component down to a child component, making them **immutable** (read-only) within the child component. They are the mechanism for component configuration. **State**, on the other hand, is a data structure used to hold data that is **internal** to a component and can be **changed** over time. When state changes, the component re-renders. A common scenario for using the `useEffect` hook is for **data fetching** from an API when a component mounts. For example, you would use `useEffect` with an empty dependency array (`[]`) to ensure the fetch operation only runs once, mimicking `componentDidMount` in class components, or with dependencies to re-fetch when certain prop/state values change."
  },
  {
    "question": "Describe the concept of **CSS specificity** and provide an ordered list from least specific to most specific selector types. How does the `!important` rule affect specificity?",
    "answer": "**CSS specificity** is the algorithm that determines which CSS rule's styles get applied when multiple rules target the same element. It's essentially a weighted value for a given selector. The ordered list from least specific to most specific is:\n1. **Type selectors** (e.g., `p`, `h1`) and **pseudo-elements** (e.g., `::before`).\n2. **Class selectors** (e.g., `.myClass`), **attribute selectors** (e.g., `[type=\"text\"]`), and **pseudo-classes** (e.g., `:hover`).\n3. **ID selectors** (e.g., `#myID`).\n4. **Inline styles** (added directly to the HTML element with the `style` attribute).\nThe `!important` rule is an exception; it has the **highest priority** and overrides all other styles, regardless of specificity, except for other `!important` rules with higher specificity or if the original rule is from a user stylesheet. It's generally considered a best practice to **avoid** using `!important` because it makes debugging and maintaining CSS much harder."
  },
  {
    "question": "Explain the concept of the **Event Loop** in JavaScript and how it enables asynchronous behavior (like `setTimeout` or fetching data) to be non-blocking in a single-threaded environment.",
    "answer": "The **Event Loop** is a crucial mechanism that allows JavaScript to perform non-blocking I/O operations despite being single-threaded. It consists of the **Call Stack**, **Heap**, **Web APIs/Node APIs**, **Callback Queue** (or Task Queue), and the **Microtask Queue**. When an asynchronous operation (e.g., `setTimeout`, `fetch`, DOM events) is encountered, it is passed to the relevant API (Web APIs in browsers). Once the asynchronous operation is complete, its associated callback function is moved to the Callback Queue or Microtask Queue. The Event Loop's job is to constantly check if the Call Stack is empty. If it is, the Event Loop takes the first function from the Microtask Queue (which has higher priority) or the Callback Queue and pushes it onto the Call Stack for execution. This cycle ensures that long-running operations don't block the main thread, maintaining a responsive user interface."
  },
  {
    "question": "How do you handle complex, multi-state global data management in a React application without relying solely on prop drilling? Briefly compare and contrast two common approaches.",
    "answer": "For complex global data management, relying on React's built-in features like **Context** combined with **`useReducer`** or external libraries like **Redux/Zustand/Jotai** is necessary to avoid **prop drilling** (passing props through many intermediate components). \n\n**1. React Context + useReducer:**\n* **Pros:** Built-in to React, requires no external library, simpler setup for moderately complex state.\n* **Cons:** Re-renders all consuming components when any part of the context value changes, which can lead to performance issues if not carefully managed (e.g., by splitting context). Not ideal for extremely large or highly dynamic state.\n\n**2. Redux (or similar state management library):**\n* **Pros:** Excellent for large-scale, highly complex applications. Provides predictable state management (via actions, reducers, and a single store). Offers powerful developer tooling and middleware support for side effects (e.g., Redux Thunk/Saga).\n* **Cons:** Introduces more boilerplate code and a steeper learning curve (especially Redux Toolkit). Overkill for smaller applications."
  },
  {
    "question": "In the context of responsive web design using HTML and CSS, what is the purpose of the **viewport meta tag** and how do **media queries** enable different layouts for various screen sizes?",
    "answer": "The **viewport meta tag** (`<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">`) is crucial for responsive design. Its primary purpose is to tell the browser to set the width of the viewport equal to the device's screen width (`width=device-width`) and set the initial zoom level to 1 (`initial-scale=1.0`). Without this tag, mobile browsers often render the page at a default desktop width (e.g., 980px) and then scale it down, resulting in tiny, unreadable text.\n\n**Media queries** are CSS constructs that allow you to apply styles selectively based on the characteristics of the device, most commonly its **width**. They follow the syntax `@media screen and (max-width: 600px) { ... }`. This allows a developer to define different sets of CSS rules that are applied only when the screen meets certain criteria (e.g., a maximum width of 600 pixels for mobile view). This enables the creation of multiple layouts—a technique known as **Adaptive** or **Responsive** design—where elements might stack, change font sizes, or disappear entirely depending on the viewing device."
  }
]